# core/query/executor.py
from typing import Dict, Any, List, Callable, Optional
from collections import deque
import json

# adapters (created separately)
from core.query.qdrant_adapter import QdrantAdapter
from core.query.embedder_adapter import embed as adapter_embed
from core.query.graph_adapter import graph as adapter_graph

# try real libs indicators (kept for optional behavior)
try:
    from qdrant_client import QdrantClient
    from qdrant_client.http.models import Filter, FieldCondition, MatchValue, Range
    QDRANT_AVAILABLE = True
except Exception:
    QDRANT_AVAILABLE = False

try:
    import lmdb
    LMDB_AVAILABLE = True
except Exception:
    LMDB_AVAILABLE = False

# fast json
try:
    import orjson as _orjson
    def _dumps(obj): return _orjson.dumps(obj)
    def _loads(b): return _orjson.loads(b)
except Exception:
    def _dumps(obj): return json.dumps(obj).encode("utf-8")
    def _loads(b): return json.loads(b.decode("utf-8"))

# ---------------------------
# Simple LMDB wrapper (metadata store)
# ---------------------------
class LMDBMetaStore:
    def __init__(self, path: str = "data/lmdb_meta", map_size: int = 1 << 30):
        if LMDB_AVAILABLE:
            self.env = lmdb.open(path, map_size=map_size, subdir=True, create=True, lock=True)
        else:
            self.env = None
            self._mem: Dict[str, Any] = {}

    def put(self, key: str, value: Dict[str, Any]):
        if self.env:
            with self.env.begin(write=True) as txn:
                txn.put(key.encode("utf-8"), _dumps(value))
        else:
            self._mem[key] = value

    def get(self, key: str) -> Optional[Dict[str, Any]]:
        if self.env:
            with self.env.begin(write=False) as txn:
                v = txn.get(key.encode("utf-8"))
                if v is None:
                    return None
                return _loads(v)
        else:
            return self._mem.get(key)

    def scan(self):
        """Yield (key, value) for all items. Simple full-scan used for naive query support."""
        if self.env:
            with self.env.begin(write=False) as txn:
                with txn.cursor() as cur:
                    for k, v in cur:
                        yield k.decode("utf-8"), _loads(v)
        else:
            for k, v in self._mem.items():
                yield k, v

    def query_naive(self, filter_ast: Dict[str, Any], limit: Optional[int] = None, offset: Optional[int] = None):
        def eval_cmp(field_val, cmp_op, comp_value):
            try:
                if cmp_op == "=":
                    return field_val == comp_value
                if cmp_op == "!=":
                    return field_val != comp_value
                if cmp_op == "<":
                    return field_val < comp_value
                if cmp_op == "<=":
                    return field_val <= comp_value
                if cmp_op == ">":
                    return field_val > comp_value
                if cmp_op == ">=":
                    return field_val >= comp_value
                if cmp_op == "CONTAINS":
                    if isinstance(field_val, (list, tuple)):
                        return comp_value in field_val
                    if isinstance(field_val, str):
                        return str(comp_value) in field_val
                    return False
            except Exception:
                return False
            return False

        def eval_expr(ast, meta):
            if ast is None:
                return True
            op = ast.get("op")
            if op == "cmp":
                parts = ast["field"].split(".")
                fv = meta
                for p in parts:
                    if isinstance(fv, dict) and p in fv:
                        fv = fv[p]
                    else:
                        fv = None
                        break
                return eval_cmp(fv, ast["cmp"], ast["value"])
            if op == "and":
                return eval_expr(ast["left"], meta) and eval_expr(ast["right"], meta)
            if op == "or":
                return eval_expr(ast["left"], meta) or eval_expr(ast["right"], meta)
            if op == "not":
                return not eval_expr(ast["arg"], meta)
            if op == "exists":
                parts = ast["field"].split(".")
                fv = meta
                for p in parts:
                    if isinstance(fv, dict) and p in fv:
                        fv = fv[p]
                    else:
                        return False
                return True
            return False

        out = []
        skipped = 0
        for k, md in self.scan():
            if filter_ast and not eval_expr(filter_ast, md):
                continue
            if offset and skipped < offset:
                skipped += 1
                continue
            out.append(md)
            if limit and len(out) >= limit:
                break
        return out

# ---------------------------
# AST -> Qdrant Filter helper (kept minimal)
# ---------------------------
def ast_to_qdrant_filter(ast):
    # keep placeholder: adapter may ignore complex filters for now
    return None

# ---------------------------
# QueryExecutor
# ---------------------------
class QueryExecutor:
    def __init__(
        self,
        qdrant_client: Optional[Any] = None,
        qdrant_collection: Optional[str] = None,
        lmdb_store: Optional[LMDBMetaStore] = None,
        embedder: Optional[Callable[[str], List[float]]] = None,
        graph: Optional[Any] = None
    ):
        # qdrant: wrap member B via adapter
        if qdrant_client is None:
            self.q = QdrantAdapter(collection=qdrant_collection or "default_collection")
        else:
            self.q = QdrantAdapter(qdrantdb=qdrant_client, collection=qdrant_collection or "default_collection")
        self.q_collection = qdrant_collection or "default_collection"

        # lmdb
        self.lmdb = lmdb_store or LMDBMetaStore()

        # embedder
        self.embed = embedder or adapter_embed

        # graph (local adjacency store)
        self.graph = graph or adapter_graph

    # --- public execute ---
    def execute(self, ast: Dict[str, Any]):
        op = ast.get("op")
        if op == "find_nodes":
            return self._exec_find_nodes(ast)
        if op == "get_node":
            return self._exec_get_node(ast)
        if op == "get_vector":
            return self._exec_get_vector(ast)
        if op == "search_vector":
            return self._exec_search_vector(ast)
        if op == "find_path":
            return self._exec_find_path(ast)
        raise Exception("Unsupported op: " + str(op))

    # --- implementations ---
    def _exec_find_nodes(self, ast):
        res = self.lmdb.query_naive(ast.get("where"), limit=ast.get("limit"), offset=ast.get("offset"))
        return res

    def _exec_get_node(self, ast):
        nid = ast["node_id"]
        md = self.lmdb.get(nid)
        return md

    def _exec_get_vector(self, ast):
        nid = ast["node_id"]
        # try adapter get_point (adapter returns None by default)
        point = None
        try:
            point = self.q.get_point(self.q_collection, point_id=nid)
            if point and hasattr(point, "vector"):
                return {"node_id": nid, "vector": point.vector}
        except Exception:
            pass
        md = self.lmdb.get(nid) or {}
        return {"node_id": nid, "vector": md.get("vector")}

    def _exec_search_vector(self, ast):
        # get vector to search
        if ast.get("embed"):
            vec = self.embed(ast["embed"])
        elif ast.get("node_id"):
            tmp = self._exec_get_vector({"op":"get_vector","node_id":ast["node_id"]})
            vec = tmp.get("vector")
            if vec is None:
                raise Exception("vector for node_id not found")
        else:
            raise Exception("SEARCH VECTOR requires EMBED(...) or node_id=...")

        # try adapter search
        hits = []
        try:
            hits = self.q.search(collection_name=self.q_collection, query_vector=vec, limit=ast.get("k", 10), query_filter=None)
        except Exception:
            hits = []

        out = []
        for h in hits:
            pid = str(h.get("id"))
            meta = self.lmdb.get(pid)
            out.append({"id": pid, "score": h.get("score"), "meta": meta})
        if out:
            return out

        # fallback naive LMDB scan + dot product
        candidates = []
        for k, md in self.lmdb.scan():
            v = md.get("vector")
            if not v:
                continue
            try:
                score = sum(x*y for x,y in zip(v, vec))
                candidates.append({"id": k, "score": score, "meta": md})
            except Exception:
                continue
        candidates.sort(key=lambda x: x["score"], reverse=True)
        return candidates[:ast.get("k",10)]

    def _exec_find_path(self, ast):
        src = ast["from"].get("node_id") or ast["from"].get("label")
        dst = ast["to"].get("node_id") or ast["to"].get("label")
        maxhops = ast.get("maxhops") or 10
        visited = set([src])
        q = deque([(src, [src])])

        while q:
            node, path = q.popleft()
            if node == dst:
                if ast.get("return") == "edges":
                    edges = [(path[i], path[i+1]) for i in range(len(path)-1)]
                    return {"path": path, "edges": edges}
                return {"path": path}
            if len(path)-1 >= maxhops:
                continue
            neighbors = []
            try:
                neighbors = self.graph.get_neighbors(node)
            except Exception:
                try:
                    neighbors = self.graph.neighbors(node)
                except Exception:
                    neighbors = []
            for nb in neighbors:
                if nb in visited:
                    continue
                visited.add(nb)
                q.append((nb, path + [nb]))
        return {"path": None}

# ---------------------------
# LocalGraphStoreFallback (kept for completeness)
# ---------------------------
class LocalGraphStoreFallback:
    def __init__(self):
        self._adj: Dict[str, List[str]] = {}

    def seed(self, adj_map: Dict[str, List[str]]):
        self._adj.update(adj_map)

    def get_neighbors(self, node_id: str) -> List[str]:
        return self._adj.get(node_id, [])

    def neighbors(self, node_id: str) -> List[str]:
        return self.get_neighbors(node_id)


# ---------------------------
# Convenience wrapper used by Member A's API
# ---------------------------
from parser import parse

def execute_query(query_str: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
    ast = parse(query_str)
    exe = QueryExecutor(qdrant_client=None, qdrant_collection=None, lmdb_store=LMDBMetaStore(), embedder=adapter_embed, graph=adapter_graph)
    res = exe.execute(ast)
    return {"ast": ast, "result": res}
